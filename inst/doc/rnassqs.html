<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>API Information</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p><code>rnassqs</code> is a package to access the QuickStats API from national agricultural statistics service (NASS) at the USDA. There are at least two good reasons to do this:</p>

<ol>
<li><p><strong>Reproducibility</strong>. downloading the data via an R script creates a trail that you can revisit later to see exactly what you downloaded. It also makes it much easier for people seeking to replicate your results to ensure they have the same data that you do.</p></li>
<li><p><strong>DRY</strong>. Don&#39;t repeat yourself. Downloading data via API makes it easier to download new data as it is released, and to fetch multiple variables, geographies, or time frames without having to manually click through the QuickStats tool for each data request.</p></li>
</ol>

<p>In the beginning it can be more confusing, and potentially take more time, but as you become familiar with the variables and calls of the <code>rnassqs</code> package and the QuickStats database, you&#39;ll be able to quickly and easily download new data.</p>

<h2>API Information</h2>

<p>The USDA-NASS Quick Stats API has a graphic interface here: <a href="https://quickstats.nass.usda.gov">https://quickstats.nass.usda.gov</a>. 
Information on the query parameters is found at <a href="https://quickstats.nass.usda.gov/api#param_define">https://quickstats.nass.usda.gov/api#param_define</a>.</p>

<h2>A quick example</h2>

<p>First, obtain an API key from the &#39;Quick Stats&#39; service: <a href="https://quickstats.nass.usda.gov/api">https://quickstats.nass.usda.gov/api</a>. Then we can make a query. Here we request the number of farm operators by operation acreage in Oregon in 2012.</p>

<pre><code>library(rnassqs)

# Specify the query parameters
params &lt;- list(
  commodity_desc = &quot;OPERATORS&quot;,
  domain_desc = &quot;AREA OPERATED&quot;
  agg_level_desc = &quot;STATE&quot;,
  state_alpha = &quot;OR&quot;,
  year = 2012
)

# Check that our record request is under the 50,000 limit
nassqs_record_count(params)

# Get the data
d &lt;- nassqs(params)
</code></pre>

<p>Parameters need not be specified in a list and need not be capitalized. The following is equivalent</p>

<pre><code># Get the data specifying each parameter as a separate argument to the 
# function `rnassqs`
d &lt;- nassqs(commodity_desc = &quot;operators&quot;, 
            domain_desc = &quot;area operated&quot;,
            agg_level_desc = &quot;state&quot;,
            state_alpha = &quot;or&quot;,
            year = 2012)
</code></pre>

<h2>Convenience functions</h2>

<p>A growing list of convenience functions makes querying simpler. For example, you can retrieve yields and acres with</p>

<pre><code># Set parameters
params &lt;- list(
  commodity_desc = &quot;APPLES&quot;,
  domaincat_desc = &quot;NOT SPECIFIED&quot;
  agg_level_desc = &quot;STATE&quot;,
  state_alpha = &quot;OR&quot;,
  year = 2012
)

# Yields and Acres
yields &lt;- nassqs_yields(params)
acres &lt;- nassqs_acres(params)
</code></pre>

<h2>Detailed usage</h2>

<h3>Step 1: Authentication</h3>

<p>the QuickStats API requires authentication. You can get an API Key <a href="https://quickstats.nass.usda.gov/api">here</a>. Once you have a key, you can use it in any of the following ways:</p>

<h4>Add it to your .Renviron file</h4>

<p>In your home directory create or edit the <code>.Renviron</code> file, and add <code>NASSQS_TOKEN = &lt;your api key&gt;</code> to the file. <code>R</code> sessions will have the variable set automatically, and <code>rnassqs</code> will detect this when querying data. If you use Rstudio, you can also use <code>usethis::edit_r_environ</code> to open your <code>.Renviron</code> file and add the key. This will create a new system environmental variable when you start a new <code>R</code> session. You can also set the environmental variable directly with <code>Sys.setenv(NASSQS_TOKEN = &lt;your api key&gt;</code>.</p>

<h4>Put it in a file</h4>

<p>You can add a file to your project directory and ignore it via <code>.gitignore</code> if you&#39;re using github. The advantage of this method is that you don&#39;t have to think about the API key for the rest of the project, but you have to repeat this process for every new project, and you risk forgetting to add it to <code>.gitignore</code>. Once the api key is in a file, you can use it like this:</p>

<pre><code># Load the api key
api_key &lt;- readLines(&quot;&lt;file name with api key&gt;&quot;)
nassqs_auth(key = api_key)
</code></pre>

<h4>Add it interactively</h4>

<p>If you don&#39;t want to add the API key to a file or store it in your <code>.Renviron</code>, you can enter it in the console in a session. This is less easy because you have to enter (or copy-paste) the key each time you begin an <code>R</code> session. In addition, you won&#39;t be able to automate running your script, since it will stop and ask you to provide an api key.</p>

<pre><code># Checks if the api key is set and prints it. 
# If it is not set, asks the user to set the value in the console.
nassqs_auth()
</code></pre>

<h3>Step 2: Building Queries</h3>

<p>The QuickStats API offers a bewildering array of fields on which to query. <code>rnassqs</code> tries to help navigate query building with some functions that return parameter names and valid values for those parameters. <code>nassqs_params()</code> provides the parameter names, which at the time of this writing are</p>

<pre><code class="r">library(rnassqs)

# returns a list of fields that you can query
nassqs_params()
#&gt;  [1] &quot;agg_level_desc&quot;        &quot;asd_code&quot;             
#&gt;  [3] &quot;asd_desc&quot;              &quot;begin_code&quot;           
#&gt;  [5] &quot;class_desc&quot;            &quot;commodity_desc&quot;       
#&gt;  [7] &quot;congr_district_code&quot;   &quot;country_code&quot;         
#&gt;  [9] &quot;country_name&quot;          &quot;county_ansi&quot;          
#&gt; [11] &quot;county_code&quot;           &quot;county_name&quot;          
#&gt; [13] &quot;CV&quot;                    &quot;domaincat_desc&quot;       
#&gt; [15] &quot;domain_desc&quot;           &quot;end_code&quot;             
#&gt; [17] &quot;freq_desc&quot;             &quot;group_desc&quot;           
#&gt; [19] &quot;load_time&quot;             &quot;location_desc&quot;        
#&gt; [21] &quot;prodn_practice_desc&quot;   &quot;reference_period_desc&quot;
#&gt; [23] &quot;region_desc&quot;           &quot;sector_desc&quot;          
#&gt; [25] &quot;short_desc&quot;            &quot;state_alpha&quot;          
#&gt; [27] &quot;state_ansi&quot;            &quot;state_name&quot;           
#&gt; [29] &quot;state_fips_code&quot;       &quot;statisticcat_desc&quot;    
#&gt; [31] &quot;source_desc&quot;           &quot;unit_desc&quot;            
#&gt; [33] &quot;util_practice_desc&quot;    &quot;Value&quot;                
#&gt; [35] &quot;watershed_code&quot;        &quot;watershed_desc&quot;       
#&gt; [37] &quot;week_ending&quot;           &quot;year&quot;                 
#&gt; [39] &quot;zip_5&quot;
</code></pre>

<p>Including parameter names in <code>nassqs_params</code> will return a description of the parameter(s) in question:</p>

<pre><code class="r">nassqs_params(&quot;agg_level_desc&quot;, &quot;source_desc&quot;)
#&gt; [1] &quot;agg_level_desc: Geographical level of data. Often &#39;county&#39;, &#39;state&#39;, or &#39;national&#39;, but can include other levels as well&quot;
#&gt; [2] &quot;source_desc: Data source. Either &#39;CENSUS&#39; or &#39;SURVEY&#39;&quot;
</code></pre>

<p>Documentation on all of the parameters is available at <a href="https://quickstats.nass.usda.gov/api#param_define">https://quickstats.nass.usda.gov/api#param_define</a>.</p>

<p>A list of the valid values for a given field is available via <code>nassqs_param_values(param = &lt;parameter name&gt;)</code>. For example, </p>

<pre><code>nassqs_param_values(param = &#39;source_desc&#39;)
</code></pre>

<p>returns a list of valid values for the <code>source_desc</code> parameter. </p>

<p>Building a query often involves some trial and error. One way of developing the query is to use the <a href="https://quickstats.nass.usda.gov/">QuickStats web interface</a>. This is often the fastest method and provides quick feedback on the subset of values for a given query. Alternatively, you can query values for each field as above and iteratively build your query. The query in the end takes the form of a list of parameters that looks like</p>

<pre><code>params &lt;- list(commodity_desc = &quot;CORN&quot;, year__GE = 2012, state_alpha = &quot;VA&quot;)
</code></pre>

<h4>Querying a range of values</h4>

<p>Most queries will probably be for specific values such as <code>year = 2012</code>, but you may also want to query ranges of values. For those queries, append one of the following to the field you&#39;d like to modify:</p>

<ul>
<li>__LE: less than or equal</li>
<li>__LT: less than</li>
<li>__GE: greater than or equal</li>
<li>__GT: greater than</li>
<li>__LIKE: like </li>
<li>__NOT_LIKE: not like </li>
<li>__NE: not equal</li>
</ul>

<p>In the above parameter list, <code>year__GE</code> is the <code>year</code> field with the <code>__GE</code> modifier attached to it. The returned data includes all records with year greater than or equal to 2012.</p>

<h4>Querying multiple values</h4>

<p>Multiple values can be queried at once by including them in a simple list with <code>c()</code>. For example, if you&#39;d like data from both Washington and Oregon, you can write <code>state_alpha = c(&#39;WA&#39;, &#39;OR&#39;)</code>.</p>

<h4>Query limits</h4>

<p>The API only returns queries that return 50,000 or less records, so it&#39;s a good idea to check that before running a query. Do do so, you can use <code>nassqs_record_count()</code>. Combined with an assert from the <code>assertthat</code> package, you can ensure that your queries are valid before attempting to access the data:</p>

<pre><code># Check that the number of returned records will be less than 50000
params &lt;- list(commodity_desc = &quot;CORN&quot;, year__GE = 2012, state_alpha = &quot;VA&quot;)
records &lt;- nassqs_record_count(params)
assertthat::assert_that(as.integer(records$count) &lt;= 50000)
</code></pre>

<h3>Step 3: Running Queries</h3>

<p>Once you&#39;ve built a query, running it is easy:</p>

<pre><code># Run a query given a set of parameters and an API key
nassqs(params = params, key = api_key)
</code></pre>

<h3>Step 4. Putting it all together</h3>

<p>Putting all of the above together, we have a script that looks like:</p>

<pre><code>library(rnassqs)
library(assertthat) #for checking the size of the query

# Check for the API key. This prints the key if it is set, or asks for it
# if the session is interactive
nassqs_auth()

# Get a list of available fields
parameters &lt;- nassq_params()

# Get valid values for &#39;commodity_desc&#39;
nassqs_param_values(param = &#39;source_desc&#39;)

# Set a list of parameters to query on
params &lt;- list(commodity_desc = &quot;CORN&quot;, year__GE = 2012, state_alpha = &quot;VA&quot;)

# Check that the number of returned records will be less than 50000
records &lt;- nassqs_record_count(params)
assert_that(as.integer(records$count) &lt;= 50000)

# Run a query given a set of parameters and an API key
d &lt;- nassqs(params = params, key = api_key)

# Run the same query but parse into a data.frame separately
raw &lt;- nassqs_GET(params = params, key = api_key)
parsed &lt;- nassqs_parse(raw, as = &#39;data.frame&#39;)
</code></pre>

<h2>Lists of parameters and dealing with large queries</h2>

<p>The ability of <code>rnassqs</code> to iterate over lists of parameters is especially helpful. In some cases you may wish to collect many different sets of data, and in others your queries may be larger than the API restriction of 50,000 records. In both cases iterating over a list of parameters is helpful.</p>

<h3>Iterating to reduce individual query size</h3>

<p>Generally the best way to deal with large queries is to make multiple queries subset by year if possible, and by geography if not. Some care is needed if subsetting by geography. Due to suppression of data, the <em>sum of all counties in a state will not necessarily equal the state value</em>. Moreover, some data is collected only at specific geographies. It is best to start by iterating over years, so that if you want say all county cash rents on irrigated land for every year since they became available in 2008, you can iterate by doing the following:</p>

<pre><code># Define the list of parameters to use repeatedly
param_list &lt;- list(
  sector_desc = &quot;ECONOMICS&quot;,
  commodity_desc = &quot;RENT&quot;,
  prodn_practice_desc = &quot;IRRIGATED&quot;,
  class_desc = &quot;CASH, CROPLAND&quot;,
  agg_level_desc = &quot;COUNTY&quot;,
  domaincat_desc = &quot;NOT SPECIFIED&quot;)

# Iterate through each year to get data  
data_list &lt;- lapply(2008:2017, function(yr) {
  params &lt;- param_list
  params[[&#39;year&#39;]] &lt;- yr
  nassqs(params)
})

# Using dplyr to bind the data list
library(dplyr)
df &lt;- rbind_list(data_list)

# Using data.table to bind the data list
library(data.table)
dt &lt;- rbindlist(data_list)
</code></pre>

<p>Subsetting by geography works similarly, looping over the geography variable (usually <code>state_alpha</code> or <code>county_code</code> or the like) in lapply.</p>

<h3>Iterating over lists of parameters</h3>

<p>Similar to above, at times it is helpful to make multiple queries and bind the data into a single <code>data.frame</code>. For example, you may want to collect the many different categories of acres for every Agricultural Census since 1997, which you can do with something like</p>

<pre><code># First define a base parameter list to modify for each new query
base_params &lt;- list(
  source_desc = &quot;CENSUS&quot;,
  sector_desc = &quot;ECONOMICS&quot;,
  commodity_desc = &quot;AG LAND&quot;,
  agg_level_desc = &quot;COUNTY&quot;,
  unit_desc = &quot;ACRES&quot;,
  statisticcat_desc = &quot;AREA&quot;,
  domain_desc = &quot;TOTAL&quot;,
  domaincat_desc = &quot;NOT SPECIFIED&quot;,
  year_GE = 1997
)

# List of parameters that vary for each query
param_list &lt;- list(
  ag_land_other = list(
    class_desc = &quot;(EXCL CROPLAND &amp; PASTURELAND &amp; WOODLAND)&quot;), 
  ag_land_irr = list(
    prodn_practice_desc = &quot;IRRIGATED&quot;,
    class_desc = &quot;ALL CLASSES&quot;),
  ag_woodland = list(
    class_desc = &quot;WOODLAND&quot;),
  ag_pastureland = list(
    class_desc = &quot;PASTURELAND, (EXCL CROPLAND &amp; WOODLAND)&quot;),
  ag_cropland = list(
    class_desc = &quot;CROPLAND&quot;),
  ag_cropland_excl_harvested = list(
    class_desc = &quot;CROPLAND, (EXCL HARVESTED &amp; PASTURED)&quot;),
  ag_cropland_harvested = list(
    class_desc = &quot;CROPLAND, HARVESTED&quot;,
    prodn_practice_desc = &quot;ALL PRODUCTION PRACTICES&quot;),
  ag_cropland_harvested_irr = list(
    class_desc = &quot;CROPLAND, HARVESTED&quot;,
    prodn_practice_desc = &quot;IRRIGATED&quot;)
  )

  # Iterate through different variable queries
  data_list &lt;- lapply(param_list, function(var_params) {
    # Create the new parameter list and append the query items that vary
    # by query
    params &lt;- base_params
    for(n in names(var_params)) { 
      params[[n]] &lt;- var_params[[n]]
    }
    nassqs(params)
  })

  # Then rbind_list() or rbindlist() as above
</code></pre>

<h2>Under the hood</h2>

<p><code>nassqs</code> is a wrapper around the <code>nassqs_GET</code> function, which uses <code>httr::GET</code> to make an HTTP GET request to the Quick Stats API. If you need to access the underlying request object generated by the GET call, you can use <code>nassqs_GET</code> to return the request object. The <code>rnassqs</code> package also has a <code>nassqs_parse</code> function that will process a request object into a data.frame, list, or raw text. <code>nassqs</code> does handles both together, but you can replicate that functionality with low-level functions as follows:</p>

<pre><code># Make a HTTP GET request and parse into a data.frame with separate
# function calls. The below is equivalent to 
# &#39;nassqs(params, key = api_key)&#39;
request &lt;- nassqs_GET(params = params, key = api_key)
parsed &lt;- nassqs_parse(request, as = &#39;data.frame&#39;)
</code></pre>

</body>

</html>
